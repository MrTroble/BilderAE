n = 4000 # element coutn
k = 4    # tree element count

a = [] # elements
s = [] # tree
buckets = []
oracles = []

for i in range(n):
    j = 1
    while j < k:
        j = j*2 + (a[i] > s[j]) # switch to child
    bucket = j - k # because out of bounds therefore -k
    buckets[bucket] += 1
    oracles[i] = bucket

# Unroll methods -> ILP 
# -> Unroll the tree traversal -> j = j*2 calls
# -> Unroll first loop and calculate two elements in the same loop with alternating steps

# Range parameter because we do it inplace

limit = 100 # lower bound for recursion

def swap(a, b): pass
def skipElements(a): pass
def sort(x): pass

def qSort(a, l , r):
    while r - l > limit: # Recursion unroll only call one recursion per loop other halfe is done in this one
        pivotId = 0 #pick pivot
        pivot = a[pivotId] # get pivot
        swap(a[l], a[pivotId]) # move pivot to front
        i = l
        j = r
        while True:
            # skip correct
            skipElements(i)
            skipElements(j)
            # break if finished
            if i <= j: break
            swap(i, j) # otherwise swap
        # recurse only for the smaler one to saver performance
        if i < (l + r)/2: 
            qSort(a, l, j)
            l = j
        else:
            qSort(a, i, r)
            r = i
    sort(a[l:r])

# probablistic 1.4x comparisons
# median of three 1.2x
# ->>>> The better the pivot the worse the branch misses
# Better Integer Keys -> Naive worse bc of 

# Sample Sort

def sampleSort(e, k):
    if n / k < limit: sort(e)
    pivotElements = e[:k] # get random k element as pivots with sentinals inf and -inf
    for ei in e:
        bucket = findBucket(ei)
        buckets[bucket].append(ei)
    return sampleSort(buckets[0]) # sampleSort(buckets[1]) ....

# Super Scalar Sample Sort
def findBucket(e): # See above use binary tree
    j = 1
    while j < k:
        j = j*2 + (e > s[j]) # switch to child
    bucket = j - k # because out of bounds therefore -k
    buckets[bucket] += 1
    oracles[i] = bucket
    return bucket

def sssSort(e, k):
    if n / k < limit: sort(e)
    pivotElements = e[:k] # get random k element as pivots with sentinals inf and -inf
    for ei in e:
        bucket = findBucket(ei)
    # spans over bucket array
    output = []
    # prefix sum for bOffset
    bOffset = 0
    for ei in e:
        output[buckets[ei] + bOffset] = ei
    return sampleSort(buckets[0]) # sampleSort(buckets[1]) ....

# Merge Sort Striping
# For multi disk D use prefetch buffer or Dk buffer
# prediction sequence is generated by form runs
# random permutation -> Buffered Writing
